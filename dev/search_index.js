var documenterSearchIndex = {"docs":
[{"location":"final_writeup/#DZIGA.jl-:-a-package-that-greedily-solves-for-the-Google-Hashcode-2014-challenge","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","text":"","category":"section"},{"location":"final_writeup/","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","text":"for the MIT class 6.S083/C25, or [Julia: Solving Real-World Problems with Computation, Fall 2022","category":"page"},{"location":"final_writeup/","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","text":"](https://github.com/mitmath/JuliaComputation)","category":"page"},{"location":"final_writeup/","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","text":"The goal of the Google Hashcode 2014 challenge is to choose a route for n Google StreetView cars that allows them to traverse as many unique meters of a given city as possible within a limited amount of time. This is a computationally hard problem, so greedy, approximate solutions seem necessary when dealing with realistically large datasets. ","category":"page"},{"location":"final_writeup/","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","text":"In the canonical dataset given for this challenge, we are asked to plan for 8 cars traveling across the streets of Paris for 54000 seconds (15 hours).","category":"page"},{"location":"final_writeup/","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","text":"DZIGA.jl is a Julia package that can solve this challenge through the function DZIGA.greedy_planner(city::City). This input City struct and output Solution struct come from Guillaume Dalle's HashCode2014.jl package.","category":"page"},{"location":"final_writeup/#DZIGA's-greedy-planning-algorithm","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"DZIGA's greedy planning algorithm","text":"","category":"section"},{"location":"final_writeup/","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","text":"Best-first search is well-suited for greedily solving the Google HashCode 2014 challenge. ","category":"page"},{"location":"final_writeup/#upper-bound-solution","page":"DZIGA.jl : a package that  greedily solves for the Google Hashcode 2014 challenge","title":"upper-bound solution","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DZIGA","category":"page"},{"location":"#DZIGA","page":"Home","title":"DZIGA","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DZIGA.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DZIGA]","category":"page"},{"location":"#DZIGA.CityGraph","page":"Home","title":"DZIGA.CityGraph","text":"CityGraph\n\nstory a city as a graph adjacency matrix for easy traversal.  Given a 'City', produce a matrix dictionary with {endpointA : {endpointB : (duration, distance)} as key-value pairs. Also create an edges vector of tuples of (endpointA, endpointB) for easy traversal.\n\nFields\n\nmatrix::Dict{Int,Dict{Int,Tuple{Int,Int}}}: a dictionary of dictionaries where the first key is the starting junction and the second key is the ending junction. The value is a tuple of the duration and distance of the street.\nedges::Vector{Tuple{Int,Int}}: a vector of tuples of the starting and ending junctions of the street.\n\n\n\n\n\n","category":"type"},{"location":"#DZIGA.get_upper_bound-Tuple{HashCode2014.City}","page":"Home","title":"DZIGA.get_upper_bound","text":"get_upper_bound(city::City) ::Int\n\nReturn the greatest possible distance you can traverse for the given City by summing the longest streets first.\n\n\n\n\n\n","category":"method"},{"location":"#DZIGA.greedy_planner-Tuple{HashCode2014.City}","page":"Home","title":"DZIGA.greedy_planner","text":"greedy_planner(city::City) ::Int\n\nGreedily the greatest possible distance you can traverse for the given City. Best algorithm we have.\n\n\n\n\n\n","category":"method"}]
}
